# 20. Valid Parentheses

Это задача с LeetCode ([ссылка](https://leetcode.com/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-interview-150)).

## Описание задачи

Дана строка `s`, содержащая только символы `'(', ')', '{', '}', '[' и ']'`. Определите, является ли входная строка валидной.

### Условия валидности

Входная строка является валидной, если выполняются следующие условия:

1. Открывающие скобки должны закрываться скобками того же типа
2. Открывающие скобки должны закрываться в правильном порядке  
3. Каждая закрывающая скобка имеет соответствующую открывающую скобку того же типа

---

## Примеры

### Пример 1

**Входные данные:** `s = "()"`

**Результат:** `true`

### Пример 2

**Входные данные:** `s = "()[]{}"`

**Результат:** `true`

### Пример 3

**Входные данные:** `s = "(]"`

**Результат:** `false`

### Пример 4

**Входные данные:** `s = "([])"`

**Результат:** `true`

### Пример 5

**Входные данные:** `s = "([)]"`

**Результат:** `false`

---

## Ограничения

- `1 <= s.length <= 10^4`
- `s` состоит только из скобок `'()[]{}'`

---

## Решения

### Общий подход

Для решения задачи используется алгоритм с использованием стека.

Основные этапы:

1. **Проверка длинны строки на четность**: 

Если длина строки нечетная, сразу возвращаем `False` т.е. невозможно сопоставить скобки попарно.

2. **Инициализация структур данных**:
   - Стек для хранения открывающих скобок
   - Словарь `mapping` для задает соответствие закрывающих скобок → открывающим.
   - Множество `open_brackets` для проверки за O(1) того, что текущий символ строки принадлежит множеству открывающих скобок

3. **Обработка символов**:

Итерируемся по каждому символу `char` в строке:
   - Если `char` содержит открывающую скобку: добавляем ее в стек
   - Если `char` содержит закрывающую скобку:
     - Проверяем стек на пустоту (если стек пуст, то - для текущей закрывающей скобки не нашлось открывающей, возвращаем `False`)
     - Проверяем есть ли в стеке открывающая скобка для текущей закрывающей (если не нашлось открывающей скобки, то возвращаем `False`)

4. **Финальная проверка**:

Если цикл завершился успешно, то стек должен быть пуст.

Т.е. для каждой закрывающей скобки из стека была найдена открывающая нужного типа.

### Варианты реализации

#### 1. Решение с использованием списка (`solution_array.py`)

**Реализация стека:**
```python
stack = []  # Динамический массив
```

**Особенности и нюансы:**
- Использует встроенный `list` Python как стек
- **Амортизированная сложность:** `append()` и `pop()` имеют O(1) в среднем случае
- **Внутреннее устройство:** Python список - это динамический массив (гетерогенный)
- **Перевыделение памяти:** При нехватке места массив увеличивается в ~1.5 раза, что дает амортизированную сложность O(1)
- **Пространственная сложность:** O(n) в худшем случае (строка из одних открывающих скобок)
- **Производительность:** Отличная для большинства случаев благодаря кэш-локальности

#### 2. Решение с использованием deque (`solution_deque.py`)

**Реализация стека:**
```python
from collections import deque
stack = deque()  # Двусторонняя очередь
```

**Особенности и нюансы:**
- Использует `deque` из модуля `collections`
- **Внутреннее устройство:** Реализован как двусвязный список
- **Гарантированная сложность:** O(1) для операций `append()` и `pop()` (реальная, не амортизированная!)
- **Преимущества:** Нет переодического reallocation памяти, стабильная производительность
- **Недостатки:** Больше накладных расходов на память из-за указателей в узлах
- **Пространственная сложность:** O(n) в худшем случае
- **Когда использовать:** При частых операциях вставки/удаления и необходимости предсказуемой производительности

### Ключевые оптимизации реализаций

#### 1. Оптимизация проверки открывающих скобок
```python
mapping = {")":"(", "]":"[", "}":"{"}
open_brackets = set(mapping.values())  # Создаем множество для O(1) поиска

for char in s:
    if char in open_brackets:  # O(1) вместо O(n)
```

**Почему это важно:**
- `char in open_brackets` (множество) → O(1)
- `char in mapping.values()` (представление значений) → O(n)
- При n=10^4 разница существенна

#### 2. Комбинированная проверка для закрывающих скобок
```python
elif not stack or stack.pop() != mapping[char]:
    return False
```

**Нюанс логики:**
- Сначала проверяем `not stack` (стек пуст)
- Если стек НЕ пуст, то выполняем `stack.pop() != mapping[char]`
- **Ленивые вычисления:** Если стек пуст, вторая часть не выполняется (избегаем исключения)

Так же ленивые вычисления булевых операций в Python называется `Short-circuit evaluation` (короткое замыкание).

- Объединение двух проверок в одну строку повышает читаемость

#### 3. Элегантная финальная проверка
```python
return not stack
```

**Логика:**
- `stack` пустой → `bool(stack)` = `False` → `not stack` = `True` ✓
- `stack` не пустой → `bool(stack)` = `True` → `not stack` = `False` ✗

### Анализ производительности

| Аспект | `list` | `deque` |
|--------|--------|---------|
| Добавление в конец | O(1) амортизированная | O(1) гарантированная |
| Удаление с конца | O(1) | O(1) |
| Накладные расходы памяти | Минимальные | Больше (указатели) |
| Кэш-локальность | Лучше | Хуже |
| Перевыделение памяти | Есть (редко) | Нет |

### Примечание о сложности операций со словарем

**dict.keys()** - возвращает представление ключей, операция `in` для ключей - O(1)

**dict.values()** - возвращает представление значений, операция `in` для значений - O(n)

**Почему так?**
- Ключи в словаре хранятся в хэш-таблице, поэтому проверка наличия ключа - O(1)
- Значения хранятся в виде линейной структуры (похожей на список), поэтому нужно проверить каждый элемент

### Рекомендации по выбору реализации

**Используйте `list` когда:**
- Простота кода важнее микрооптимизаций
- Данные помещаются в память комфортно
- Нужна максимальная скорость для типичных случаев

**Используйте `deque` когда:**
- Нужна предсказуемая производительность
- Критична стабильность времени выполнения
- Работаете с большими объемами данных
- Важно избежать пиковых задержек из-за перевыделения памяти